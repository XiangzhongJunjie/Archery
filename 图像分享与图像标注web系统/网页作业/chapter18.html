<!DOCTYPE html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <header style = "text-align: center; font-size: large;">第十八章</header>
    <title >第十八章</title>
</head>
<body>

        <div style = "margin-left: 20%; margin-right: 20%; text-align: left;">
        <a><strong>1.Spring MVC消息转换流程是怎样的？</strong></a>
        <p style="text-indent: 2em;">
            Spring MVC的消息转换流程主要包括以下几个步骤：<br>

            (1). 用户发送请求：用户在浏览器中输入URL并发送请求。<br>

            (2). DispatcherServlet捕获请求：Spring MVC的前端控制器DispatcherServlet捕获到用户请求。<br>

            (3). 解析请求URL：DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。<br>

            (4). 查找Handler：根据请求URI，DispatcherServlet在Spring MVC的配置文件中查找对应的Handler（Controller）。<br>

            (5). 转换请求和响应：DispatcherServlet将用户的请求数据（Request）转换为Java对象（Object），并将处理后的结果（ModelAndView）传递给Handler。<br>

            (6). 处理请求：Handler（Controller）接收DispatcherServlet传递的请求数据（Object），进行业务逻辑处理。<br>

            (7). 生成响应：Handler（Controller）将处理后的结果（ModelAndView）转换为响应数据，返回给DispatcherServlet。<br>

            (8). 发送响应：DispatcherServlet将Handler生成的响应数据发送回给用户。<br>

            这个过程也被称为Spring MVC的处理请求和响应的“请求-响应”机制。
        </p>
            <a><strong>2.Spring MVC拦截器的执行流程是怎样的？试编程加以说明。</strong></a>
            <p style="text-indent: 2em;">
                &emsp;&emsp;Spring MVC拦截器的执行流程如下：<br>

                (1). 用户发起请求，请求被Servlet拦截器拦截。<br>
                (2). 拦截器将请求转发给Spring MVC框架的DispatcherServlet。<br>
                (3). DispatcherServlet接收到请求，查找对应的HandlerMapping。<br>
                (4). HandlerMapping根据请求信息和配置信息找到匹配的Controller类。<br>
                (5). 如果配置了拦截器，拦截器按照顺序执行preHandle方法。<br>
                (6). preHandle方法执行完成后，将请求参数传递给Controller中的方法。<br>
                (7). Controller中的方法执行完后，返回一个ModelAndView，包括视图名称和需要传递给视图的模型数据。<br>
                (8). 视图解析器根据名称找到视图，并将数据模型填充到视图里面，渲染成HTML内容返回给客户端。<br>

                以下是一个简单的Spring MVC拦截器示例，实现了一个简单的登录拦截器：<br>

                ```java<br>
                import javax.servlet.http.HttpServletRequest;<br>
                import javax.servlet.http.HttpServletResponse;<br>
                import org.springframework.web.servlet.HandlerInterceptor;<br>
                import org.springframework.web.servlet.ModelAndView;<br>

                public class LoginInterceptor implements HandlerInterceptor {<br>

                @Override<br>
                public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {<br>
                // 判断用户是否登录<br>
                boolean isLogin = (boolean) request.getSession().getAttribute("isLogin");<br>
                if (isLogin) {<br>
                // 用户已登录，放行<br>
                return true;<br>
                } else {<br>
                // 用户未登录，重定向到登录页面<br>
                response.sendRedirect("/login");<br>
                return false;<br>
                }<br>
                }<br>

                @Override<br>
                public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) {<br>
                // 这里可以添加一些后处理逻辑，如日志记录等<br>
                }<br>

                @Override<br>
                public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {<br>
                // 这里可以添加一些清理逻辑，如资源释放等<br>
                }<br>
                }<br>
                ```<br>

                在这个示例中，我们创建了一个名为LoginInterceptor的类，实现了HandlerInterceptor接口。在preHandle方法中，我们判断用户是否已登录。<br>
                如果已登录，则放行；如果未登录，则重定向到登录页面。其他拦截器的方法（如postHandle和afterCompletion）可以根据需要添加相应的逻辑。
            </p>
            <a><strong>3.Spring MVC框架中多个拦截器执行的顺序是怎样的？试编程加以说明。</strong></a>
            <p style="text-indent: 2em;">
                Spring MVC框架中多个拦截器的执行顺序遵循声明顺序依次执行。以下是的一个示例，演示了如何在Spring MVC中实现多个拦截器的执行顺序：<br>

                (1). 首先，创建一个自定义拦截器类，实现`HandlerInterceptor`接口：<br>

                ```java<br>
                public class MyFirstInterceptor implements HandlerInterceptor {<br>
                @Override<br>
                public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {<br>
                System.out.println("First interceptor: preHandle");<br>
                return true;<br>
                }<br>

                @Override<br>
                public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) {<br>
                System.out.println("First interceptor: postHandle");<br>
                }<br>

                @Override<br>
                public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {<br>
                System.out.println("First interceptor: afterCompletion");<br>
                }<br>
                }<br>
                ```<br>

                (2). 接下来，创建另一个自定义拦截器类，实现`HandlerInterceptor`接口：<br>

                ```java<br>
                public class MySecondInterceptor implements HandlerInterceptor {<br>
                @Override<br>
                public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {<br>
                System.out.println("Second interceptor: preHandle");<br>
                return true;<br>
                }<br>

                @Override<br>
                public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) {<br>
                System.out.println("Second interceptor: postHandle");<br>
                }<br>

                @Override<br>
                public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {<br>
                System.out.println("Second interceptor: afterCompletion");<br>
                }<br>
                }<br>
                ```<br>

                (3). 在Spring MVC配置文件中，添加这两个拦截器：<br>

                ```xml<br>
                <mvc:interceptors>
                    <mvc:interceptor>
                        <mvc:mapping path="/**" expression="hasRole('ADMIN')" />
                        <ref bean="myFirstInterceptor"/>
                    </mvc:interceptor>
                    <mvc:interceptor>
                        <mvc:mapping path="/**" expression="hasRole('USER')" />
                        <ref bean="mySecondInterceptor"/>
                    </mvc:interceptor>
                </mvc:interceptors>
                ```<br>

                (4). 最后，启动Spring MVC应用并访问相应的URL。输出结果如下：<br>

                ```<br>
                First interceptor: preHandle<br>
                Second interceptor: preHandle<br>
                First interceptor: postHandle<br>
                Second interceptor: postHandle<br>
                First interceptor: afterCompletion<br>
                Second interceptor: afterCompletion<br>
                ```<br>

                从输出结果可以看出，多个拦截器的执行顺序是按照声明顺序依次执行的。
                在这个例子中，`MyFirstInterceptor`和`MySecondInterceptor`分别对应着URL的前缀`/**`和`/**`，
                因此它们的执行顺序是先执行第一个拦截器的`preHandle`、`postHandle`和`afterCompletion`方法，
                然后执行第二个拦截器的`preHandle`、`postHandle`和`afterCompletion`方法。
            </p>
        </div>
</body>